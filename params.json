{"tagline":"A resource-oriented micro PHP framework","note":"Don't delete this file! It's used internally to help with page regeneration.","body":"Bullet\r\n======\r\n\r\nBullet is an experimental resource-oriented micro PHP framework. Bullet\r\ntakes a unique approach by parsing each path part independently and one\r\nat a time via callbacks. The path part callbacks are nested to produce\r\ndifferent responses and to follow and execute deeper paths.\r\n\r\nRequirements\r\n------------\r\n\r\n * PHP 5.3+ (heavy use of closures)\r\n * [Composer](http://getcomposer.org) for all package management and\r\n   autoloading (may require command-line access)\r\n\r\nRules \r\n-----\r\n\r\n * Apps are built around HTTP URIs and defined paths, not forced MVC\r\n   (but MVC-style separation of concerns is still highly recommenended and\r\n   encouraged)\r\n * Bullet handles **one segment of the path at a time**, and executes the\r\n   callback for that path segment before proceesing to the next segment \r\n   (path callbacks are executed from left to right, until the entire path\r\n   is consumed).\r\n * If the entire path cannot be consumed, a 404 error will be returned\r\n   (note that some callbacks may have been executed before Bullet can\r\n   know this due to the nature of callbacks and closures). Example: path\r\n   `/events/45/edit` may return a 404 because there is no `edit` path\r\n   callback, but paths `events` and `45` would have already been executed\r\n   before Bullet can know to return a 404. This is why all your primary\r\n   logic should be contained in `get`, `post`, or other method callbacks\r\n   or in the model layer (and not in the bare `path` handlers).\r\n * If the path can be fully consumed, and HTTP method handlers are present\r\n   in the path but none are matched, a 405 \"Method Not Allowed\" response\r\n   will be returned.\r\n * If the path can be fully consumed, and format handlers are present in\r\n   the path but none are matched, a 406 \"Not Acceptable\" response will\r\n   be returned.\r\n\r\nInstalling with Composer\r\n-----\r\nUse the [basic usage guide](http://getcomposer.org/doc/01-basic-usage.md),\r\nor follow the steps below:\r\n\r\nSetup your `composer.json` file at the root of your project\r\n```\r\n{\r\n    \"require\": {\r\n        \"vlucas/bulletphp\": \"*\"\r\n    }\r\n}\r\n```\r\n\r\nInstall Composer\r\n```\r\ncurl -s http://getcomposer.org/installer | php\r\n```\r\n\r\nInstall Dependencies (will download Bullet)\r\n```\r\nphp composer.phar install\r\n```\r\n\r\nCreate `index.php` (use the minimal example below to get started)\r\n```\r\n<?php\r\nrequire __DIR__ . '/vendor/autoload.php';\r\n\r\n// Your App\r\n$app = new Bullet\\App();\r\n$app->path('/', function($request) {\r\n    return \"Hello World!\";\r\n});\r\n\r\n// Run the app! (takes $method, $url or Bullet\\Request object)\r\necho $app->run(new Bullet\\Request());\r\n```\r\n\r\nUse an `.htaccess` file for mod_rewrite (if you're using Apache)\r\n```\r\n<IfModule mod_rewrite.c>\r\n  RewriteEngine On\r\n\r\n  # Reroute any incoming requestst that is not an existing directory or file\r\n  RewriteCond %{REQUEST_FILENAME} !-d\r\n  RewriteCond %{REQUEST_FILENAME} !-f\r\n  RewriteRule ^(.*)$ index.php?u=$1 [L,QSA]\r\n</IfModule>\r\n```\r\n\r\nView it in your browser!\r\n\r\nSyntax\r\n------\r\n\r\nBullet is not your typical PHP micro framework. Instead of defining a full\r\npath pattern or a typical URL route with a callback and parameters mapped\r\nto a REST method (GET, POST, etc.), Bullet parses only ONE URL segement\r\nat a time, and only has two methods for working with paths: `path` and\r\n`param`. As you may have guessed, `path` is for static path names like\r\n\"blog\" or \"events\" that won't change, and `param` is for variable path\r\nsegments that need to be captured and used, like \"42\" or \"my-post-title\".\r\nYou can then respond to paths using nested HTTP method callbacks that\r\ncontain all the logic for the action you want to perform.\r\n\r\nThis type of unique callback nesting eliminates repetitive code for\r\nloading records, checking authentication, and performing other setup\r\nwork found in typical MVC frameworks or other microframeworks where each\r\ncallback or action is in a separate scope or controller method.\r\n\r\n```\r\n$app = new Bullet\\App(array(\r\n    'template.cfg' => array('path' => __DIR__ . '/templates')\r\n));\r\n\r\n// 'blog' subdirectory\r\n$app->path('blog', function($request) use($app) {\r\n    \r\n    $blog = somehowGetBlogMapper(); // Your ORM or other methods here\r\n\r\n    // 'posts' subdirectory in 'blog' ('blog/posts')\r\n    $app->path('posts', function() use($app, $blog) {\r\n\r\n        // Load posts once for handling by GET/POST/DELETE below\r\n        $posts = $blog->allPosts(); // Your ORM or other methods here\r\n\r\n        // Handle GET on this path\r\n        $app->get(function() use($posts) {\r\n            // Display all $posts\r\n            return $app->template('posts/index', compact('posts'));\r\n        });\r\n\r\n        // Handle POST on this path\r\n        $app->post(function() use($posts) {\r\n            // Create new post\r\n            $post = new Post($request->post());\r\n            $mapper->save($post);\r\n            return $this->response($post->toJSON(), 201);\r\n        });\r\n\r\n        // Handle DELETE on this path\r\n        $app->delete(function() use($posts) {\r\n            // Delete entire posts collection\r\n            $posts->deleteAll();\r\n            return 200;\r\n        });\r\n\r\n    });\r\n});\r\n\r\n// Run the app and echo the response\r\necho $app->run(\"GET\", \"blog/posts\");\r\n```\r\n\r\n### Capturing Path Parameters\r\n\r\nPerhaps the most compelling use of URL routing is to capture path\r\nsegments and use them as parameters to fetch items from a database, like\r\n`/posts/42` and `/posts/42/edit`. Bullet has a special `param` handler\r\nfor this that takes two arguments: a `test` callback that validates the\r\nparameter type for use, and and a `Closure` callback. If the `test`\r\ncallback returns boolean `false`, the closure is never executed, and the\r\nnext path segment or param is tested. If it returns boolean `true`, the\r\ncaptured parameter is passed to the Closure as the second argument.\r\n\r\nJust like regular paths, HTTP method handlers can be nested inside param\r\ncallbacks, as well as other paths, more parameters, etc.\r\n\r\n```\r\n$app = new Bullet\\App(array(\r\n    'template.cfg' => array('path' => __DIR__ . '/templates')\r\n));\r\n$app->path('posts', function($request) use($app) {\r\n    // Integer path segment, like 'posts/42'\r\n    $app->param('int', function($request, $id) use($app) {\r\n        $app->get(function($request) use($id) {\r\n            // View post\r\n            return 'view_' . $id;\r\n        });\r\n        $app->put(function($request) use($id) {\r\n            // Update resource\r\n            $post->data($request->post());\r\n            $post->save();\r\n            return 'update_' . $id;\r\n        });\r\n        $app->delete(function($request) use($id) {\r\n            // Delete resource\r\n            $post->delete();\r\n            return 'delete_' . $id;\r\n        });\r\n    });\r\n    // All printable characters except space\r\n    $app->param('ctype_graph', function($request, $slug) use($app) {\r\n        return $slug; // 'my-post-title'\r\n    });\r\n});\r\n\r\n// Results of above code\r\necho $app->run('GET',   '/posts/42'); // 'view_42'\r\necho $app->run('PUT',   '/posts/42'); // 'update_42'\r\necho $app->run('DELTE', '/posts/42'); // 'delete_42'\r\n\r\necho $app->run('DELTE', '/posts/my-post-title'); // 'my-post-title'\r\n```\r\n\r\nReturning JSON (Useful for PHP JSON APIs)\r\n-----------------------------------------\r\n\r\nBullet has built-in support for returning JSON responses. If you return\r\nan array from a route handler (callback), Bullet will assume the\r\nresponse is JSON and automatically `json_encode` the array and return the\r\nHTTP response with the appropriate `Content-Type: application/json` header.\r\n\r\n```\r\n$app->path('/', function($request) use($app) {\r\n  $app->get(function($request) use($app) {\r\n    // Links to available resources for the API\r\n    return array(\r\n      '_links' => array(\r\n        'restaurants' => array(\r\n          'title' => 'Restaurants',\r\n          'href' => $app->url('restaurants')\r\n        ),\r\n        'events' => array(\r\n          'title' => 'Events',\r\n          'href' => $app->url('events')\r\n        )\r\n      )\r\n    );\r\n  });\r\n});\r\n```\r\n\r\n### HTTP Response Bullet Sends:\r\n```\r\nContent-Type:application/json; charset=UTF-8\r\n\r\n{\"_links\":{\"restaurants\":{\"title\":\"Restaurants\",\"href\":\"http:\\/\\/yourdomain.local\\/restaurants\"},\"events\":{\"title\":\"Events\",\"href\":\"http:\\/\\/yourdomain.local\\/events\"}}}\r\n```\r\n\r\nBullet Response Types\r\n--------------\r\n\r\nThere are many possible values you can return from a route handler in\r\nBullet to produce a valid HTTP response. Most types can be either\r\nreturned directly, or wrapped in the `$app->response()` helper for\r\nadditional customization.\r\n\r\n### Strings\r\n\r\n```\r\n$app = new Bullet\\App();\r\n$app->path('/', function($request) use($app) {\r\n    return \"Hello World\";\r\n});\r\n$app->path('/', function($request) use($app) {\r\n    return $app->response(\"Hello Error!\", 500);\r\n});\r\n```\r\nStrings result in a 200 OK response with a body containing the returned\r\nstring. If you want to return a quick string response with a different\r\nHTTP status code, use the `$app->response()` helper.\r\n\r\n### Booleans\r\n\r\n```\r\n$app = new Bullet\\App();\r\n$app->path('/', function($request) use($app) {\r\n    return true;\r\n});\r\n$app->path('notfound', function($request) use($app) {\r\n    return false;\r\n});\r\n```\r\nBoolean `false` results in a 404 \"Not Found\" HTTP response, and boolean\r\n`true` results in a 200 \"OK\" HTTP response.\r\n\r\n### Integers\r\n\r\n```\r\n$app = new Bullet\\App();\r\n$app->path('teapot', function($request) use($app) {\r\n    return 418;\r\n});\r\n```\r\nIntegers are mapped to their corresponding HTTP status code. In this\r\nexample, a 418 \"I'm a Teapot\" HTTP response would be sent.\r\n\r\n### Arrays\r\n\r\n```\r\n$app = new Bullet\\App();\r\n$app->path('foo', function($request) use($app) {\r\n    return array('foo' => 'bar');\r\n});\r\n$app->path('bar', function($request) use($app) {\r\n    return $app->response(array('bar' => 'baz'), 201);\r\n});\r\n```\r\nArrays are automatically passed through `json_encode` and the appropriate\r\n`Content-Type: application/json` HTTP response header is sent.\r\n\r\n### Templates\r\n\r\n```\r\n// Configure template path with constructor\r\n$app = new Bullet\\App(array(\r\n    'template.cfg' => array('path' => __DIR__ . '/templates')\r\n));\r\n\r\n// Routes\r\n$app->path('foo', function($request) use($app) {\r\n    return $app->template('foo');\r\n});\r\n$app->path('bar', function($request) use($app) {\r\n    return $app->template('bar', array('bar' => 'baz'), 201);\r\n});\r\n```\r\nThe `$app->template()` helper returns an instance of\r\n`Bullet\\View\\Template` that is lazy-rendered on `__toString` when the\r\nHTTP response is sent. The first argument is a template name, and the\r\nsecond (optional) argument is an array of parameters to pass to the\r\ntemplate for use.\r\n\r\n\r\nNested Requests (HMVC style code re-use)\r\n----------------------------------------\r\n\r\nSince you explicitly `return` values from Bullet routes instead of\r\nsending output directly, nested/sub requests are straightforward and easy.\r\nAll route handlers will return `Bullet\\Response` instances (even if they\r\nreturn a raw string or other data type, they are wrapped in a response\r\nobject by the `run` method), and they can be composed to form a single\r\nHTTP response.\r\n\r\n```\r\n$app = new Bullet\\App();\r\n$app->path('foo', function($request) use($app) {\r\n    return \"foo\";\r\n});\r\n$app->path('bar', function($request) use($app) {\r\n    $foo = $app->run('GET', 'foo'); // $foo is now a `Bullet\\Response` instance\r\n    return $foo->content() . \"bar\";\r\n});\r\necho $app->run('GET', 'bar'); // echos 'foobar' with a 200 OK status\r\n```\r\n\r\n\r\nRunning Tests\r\n-------------\r\n\r\nTo run the Bullet test suite, simply run `phpunit` in the root of the\r\ndirectory where the bullet files are in. Please make sure to add tests\r\nand run the test suite before submitting pull requests for any contributions.\r\n\r\nCredits\r\n-------\r\n\r\nBullet - and specifically path-based callbacks that fully embrace HTTP\r\nand encourage a more resource-oriented design - is something I have been\r\nthinking about for a long time, and was finally moved to create it after\r\nseeing [@joshbuddy](https://github.com/joshbuddy) give a presentation on [Renee](http://reneerb.com/)\r\n(Ruby) at [Confoo](http://confoo.ca) 2012 in Montr√©al.\r\n\r\n","name":"Bulletphp","google":"UA-359731-31"}